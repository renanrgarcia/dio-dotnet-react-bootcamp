# NoSQL

- SQL - scales on vertical form, demanding more computer resources. The exception is the SQL cluster, but it grows on horizontal form just for replicating data.
  - Schema: table, row, column, PK, FK
  - Performance: depends on disk system
  - Transactions: ACID (Atomicity, Consistency, Isolation, Durability)
- NoSQL - scales natively on horizontal form. Node sharding is the most common example of NoSQL.
  - Schema: there are no previously rules (schema-free/schemaless)
  - Performance: depends on cluster size and network bandwidth
  - Transactions: BaSE (Basically available, Soft-state, Eventually consistent)
- More used: MongoDB, Redis, Cassandra (column/column family), Neo4j (Graphs)
- Types: document, key-value, graph, wide-column store

## Graphs

- Graph: a collection of nodes and edges
- `Neo4j` used cypher language for queries

## Column/Column family

- Column: a collection of rows, only reserve space for the filled columns
- `Cassandra` (Facebook created based on Bigtable - Google) uses CQL (Cassandra Query Language) for queries
  - katacoda.com
- Focus on reading data in high volume, consuming data by its Primary Key
- Concepts:
  - Keyspace (Database) - group of columns families
  - Column family/table (Table) - group of columns
  - Row key (PK) - represents one column's row
  - Column - represents a value (Name, Value, Timestamp)
- Uses examples: transactions registrer (puchase records, test results, etc)

## Key/value

- Key: unique identifier; value: data
- Good performance on cloud, bad search capability
- `Redis`: used to DB, cache, message broker and queue
  - High performance, data structure on memory, versatile, replicating and persistent data
  - try.redis.io

## Document

- Data and documents autocontained and autodescribed. Permits redundance and inconsistency. Free of schemas, using JSON, XML, CSV, etc.
- `MongoDB`

## MongoDB

- Open source, High performance, Schema-free, uses JSON to store data (BSON - Binary JSON: key-value)
- Index is used to search, auto-sharding (horizontal scaling), map-reduce (aggregation to process data), GridFS (file storage)
- Rich Query language, focus on great data volume, not necessarily structured
- When not to use:
  - Need for relationships/joins
  - ACID properties and transactions are important
  - Some payment entities don't homologue systems with DBs different than relational ones
- Items
  - Document => Tuple/Record
  - Collection => Table
  - Embedding/linking => Join
- Good practices
  - Avoid too large documents
  - Use objectives and short field names
  - Analyse and optimize queries using `explain()`
  - Update only the fields that are changing
  - Avoid negation on querys
  - Lists/arrays can't grow limitlessly

## Schema Design

- Embedding

  - Autocontained Document (Reference inside the document - sub-document)
  - Ex:

  ```JSON
  {
    "name": "John",
    "addresses": [
      {
        "street": "10th Street",
        "city": "New York"
      },
      {
        "street": "20th Street",
        "city": "New York"
      }
    ]
  }
  ```

  - Recommended to One-to-one relationship (Key/Value)
  - Recommended to One-to-few relationship (Sub-document)
  - Pros:
    - Only one query to the database
    - Update register in only one operation
  - Cons:
    - 16 MB per document

- Reference

  - Dependency of another documents or collections
  - Ex:

  ```JSON
  {
    "name": "John",
    "address": [ // reference to another objects
      ObjectId("1234"),
      ObjectId("5678")
    ]
  }
  ```

  - Recommended to One-to-many/Many-to-many relationship (Reference)
  - Pros:
    - Smaller documents
    - No duplicated information
    - Used when data not acessed in every query
  - Cons:
    - Two or more query or $lookup using

## JSON/BSON

- BSON = JSON with binary values
- BSON has some types: ObjectID, Date, etc

## CLI commands

- `mongo --host 127.0.0.1:27017 -p password -u user`
